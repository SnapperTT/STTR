#hdr
// STTR - STT Reflection Library
// By Liam Twigger - 2020
// @SnapperTheTwig
// Public Domain

#include <type_traits>
#include <vector>
#include <cassert>
#include <cstring>
#include <string>

#define STTR_ADD_VISITOR(mVisitorType) 								\
	if (v->getSignature() == mVisitorType::getSignatureStatic()) { 	\
		mVisitorType * vv = (mVisitorType *) v; 					\
		vv->visit(this); 											\
		return;														\
		}
		
#define STTR_BTOS(B) (B ? "true" : "false")

// STTR_VISITORS Must be defined before #include "sttr.h"
//#define STTR_VISITORS \
//	STTR_ADD_VISITOR(visitoclass_x) \
//	STTR_ADD_VISITOR(visitoclass_y) \
//	STTR_ADD_VISITOR(visitoclass_z) 

//#define STTR_VISITORS
// \
	STTR_ADD_VISITOR(Typename_Extractor_Visitor);

namespace sttr {
template<typename T>
class Reg;

// Converts a type to a unique address
template<typename T>
static char * getTypeSignature();
}
#end

#src
// Converts a type to a unique address
namespace sttr {
template<typename T>
static char * getTypeSignature() {
	static char R;
	return &R;
	}
}
	
#end

namespace sttr {
	
std::string getTypeName_filterTypeOut(const std::string & in) {
	// Find "with T = " and stop when reaching ";"
	size_t start = in.find("T = ");
	if (start == std::string::npos) return in;
	std::string r = in.substr(start+4);
	size_t end = r.find(";");
	return r.substr(0,end);
	}

/// Prints the type of a function
template<typename T>
std::string getTypeName() {
	return sttr::getTypeName_filterTypeOut(__PRETTY_FUNCTION__);
	}

class Visitor_Base {
public:
	template<typename T>
	void visit(sttr::Reg<T> * RB) {
		//cout << "Visitor_Base" << endl;
		}
		
	virtual void * getSignature() {
		return getSignatureStatic();
		}
	static void * getSignatureStatic() {
		return (void*) sttr::getTypeSignature<Visitor_Base>();
		}
	};
	
/// Example visitor - extracts a type without rtti
/// Usage: 
/// Typename_Extractor_Visitor RTEV
/// 
class Typename_Extractor_Visitor : public Visitor_Base {
public:
	std::string type_name_out;
	
	template<typename T>
	void visit(Reg<T> * RB) {
		type_name_out = sttr::getTypeName<decltype(RB->func)>();
		}
	
	void * getSignature() {
		return getSignatureStatic();
		}
	static void * getSignatureStatic() {
		return (void*) sttr::getTypeSignature<Typename_Extractor_Visitor>();
		}
	};
	

class RegBase {
public:
	const char * name;
	bool isStatic;
	bool isConst;
	bool isVariable;
	bool isFunction;
	
	// For your usage
	uint32_t userFlags;
	std::string userString;
	void * userData;
	
	RegBase(const char * _name) : name(_name), isStatic(false), isConst(false), isVariable(false), isFunction(false), userFlags(0), userString(""), userData(NULL) {}
	
	virtual void visit(Visitor_Base * V) {}
	virtual unsigned char const * getAddr() { return 0; }
	};
	
template<typename T>
class Reg : public RegBase {
public:
	T func;
	
	Reg(T v, const char * _name) : func(v), RegBase(_name) {}
	
	void visit(Visitor_Base * v) {
		// Upcast and get the right visit
		STTR_ADD_VISITOR(Typename_Extractor_Visitor)
		
		#ifdef STTR_VISITORS
			STTR_VISITORS
		#else
			#warning STTR_VISITORS macro not defined! To suppress this warning define it as an empty string "#define STTR_VISITORS". To add a visitor use #define STTR_VISITORS STTR_ADD_VISITOR(visitoclass_type) STTR_ADD_VISITOR(anothevisitoclass_type) ... etc.
		#endif
		v->visit(this);
		}
	
	/// Get the raw address of a pointer
	unsigned char const * getAddr() {
		unsigned char const * first  = reinterpret_cast<unsigned char *>(&func);
		return reinterpret_cast<unsigned char *>(*first);
		}
	};

class RegNamespace {
public:
	RegNamespace * parent;
	const char * name;
	std::vector<RegBase*> members;
	std::vector<RegNamespace>classes;
	RegBase * thisClass;
	
	RegNamespace(const char * _name) : parent(NULL), name(_name), thisClass(NULL) {}
	~RegNamespace() {
		for (RegBase * RB : members) delete RB;
		if (thisClass) delete thisClass;
		}
	
	template <typename T>
	RegNamespace & regField(T v, const char * _name) {
		RegBase * R = new Reg<T>(v,_name);
		R->isFunction = std::is_function<typename std::remove_pointer<T>::type>::value;
		R->isVariable = !R->isFunction;
		R->isConst = std::is_const<typename std::remove_pointer<T>::type>::value;
		R->isStatic = parent && !std::is_member_pointer<T>::value;
		members.push_back(R);
		return *this;
		}
		
	RegNamespace & setUserFlags (const uint32_t & userFlags) {
		// Sets the userFlags for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserFlags without registering a field");
		RegBase * R = members[members.size()-1];
		R->userFlags = userFlags;
		return *this;
		}
	RegNamespace & setUserString (const std::string & userString) {
		// Sets the userString for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserString without registering a field");
		RegBase * R = members[members.size()-1];
		R->userString = userString;
		return *this;
		}
	RegNamespace & setUserData (void * userData) {
		// Sets the userString for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserData without registering a field");
		RegBase * R = members[members.size()-1];
		R->userData = userData;
		return *this;
		}

	template<typename T>
	RegNamespace & beginClass(const char * _name) {
		RegNamespace R (_name);
		R.parent = this;
		R.thisClass = new Reg<T*>(NULL, _name);
		classes.push_back(R);
		return classes[classes.size()-1];
		}
		
	RegNamespace & endClass() {
		if (parent) return *parent;
		return *this;
		}
	
	RegNamespace & findClass(const char * class_name) {
		RegNamespace * R = findClassWorker(class_name);
		assert(R && "sttr::RegNamespace::findClass : class not found");
		return *R;
		}
	
	RegNamespace * findClassWorker(const char * class_name) {
		for (RegNamespace & R : classes) {
			if (R.thisClass) {
				if (!strcmp(R.thisClass->name, class_name))
					return &R;
				}		
			}
		for (RegNamespace & R : classes) {
			RegNamespace * R2 = R.findClassWorker(class_name);
			if (R2)
				return R2;
			}
		return NULL;
		}
		
	std::string toString(const int indent=0) {
		std::string r = "";
		Typename_Extractor_Visitor RTEV;
		
		for (RegBase * RB : members) {
			RB->visit(&RTEV);
			r += std::string(indent,'\t') + "\tField: "+ RB->name + "\tTypedef: " + RTEV.type_name_out + " isStatic: " + STTR_BTOS(RB->isStatic) + " , isConst: " + STTR_BTOS(RB->isConst) + ", isFunction: " + STTR_BTOS(RB->isFunction) + ", isVariable: " + STTR_BTOS(RB->isVariable) + "\n";
			}
		for (RegNamespace & RS : classes) {
			r += std::string(indent,'\t') + "class " + RS.name + ":\n";
			r += RS.toString(indent+1);
			}
		return r;
		}
	
	};
}


