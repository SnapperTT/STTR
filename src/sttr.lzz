#hdr
// STTR - STT Reflection Library
// By Liam Twigger - 2020
// @SnapperTheTwig
// Public Domain

#include <type_traits>
#include <vector>
#include <cassert>
#include <cstring>
#include <string>

#ifndef STTR_VISITOR_HEADER
	#include "sttr_visitor.h"
#endif
		
#define STTR_BTOS(B) (B ? "true" : "false")
#define STTR_CLASS_SIG() virtual void * sttr_getClassSig() { return (void*) sttr::getTypeSignature<decltype(*this)>(); }

// STTR_VISITORS Must be defined before #include "sttr.h"
//#define STTR_VISITORS \
//	STTR_ADD_VISITOR(visitoclass_x) \
//	STTR_ADD_VISITOR(visitoclass_y) \
//	STTR_ADD_VISITOR(visitoclass_z) 

//#define STTR_VISITORS
// \
	STTR_ADD_VISITOR(Typename_Extractor_Visitor);
namespace sttr {
	class RegNamespace;
	}

// Macro for registering field
#define STTR_REG(C,X) regField<C>(&C::X,#X)

#end

#src
	
#end

namespace sttr {
	
class RegBase {
public:
	const char * name;
	bool isStatic;
	bool isConst;
	bool isVariable;
	bool isFunction;
	// What owns this?
	RegNamespace * mNamespace;
	
	// For your usage
	uint32_t userFlags;
	std::string userString;
	void * userData;
	
	RegBase(const char * _name) : name(_name), isStatic(false), isConst(false), isVariable(false), isFunction(false), mNamespace(NULL), userFlags(0), userString(""), userData(NULL) {}
	virtual ~RegBase(){}
	
	virtual void* construct() { return (void *) 0; }
	
	virtual void visit(Visitor_Base * V) {}
	virtual std::string getTypeName() { return ""; }
	virtual std::string getTypePointingTo() { return ""; }
	virtual unsigned char const * getAddr() const { return 0; }
	virtual const long long int getOffset() const { return 0; }
	};

template<typename T>
void* construct_worker(T func, std::false_type isVariable) { return NULL; }
template<typename T>
void* construct_worker(T func, std::true_type isVariable) {
	using TBase = typename std::remove_pointer<T>::type;
	return (void*) new TBase;
	}


template<typename T, typename CT>
class Reg : public RegBase {
public:
	T func;
	
	Reg(T v, const char * _name) : RegBase(_name), func(v) {}
	virtual ~Reg(){}
	
	void visit(Visitor_Base * v) {
		// Upcast and get the right visitor
		#ifdef STTR_VISITORS
			STTR_VISITORS
		#else
			#warning STTR_VISITORS macro not defined! To suppress this warning define it as an empty string "#define STTR_VISITORS". To add a visitor use #define STTR_VISITORS STTR_ADD_VISITOR(visitoclass_type) STTR_ADD_VISITOR(anothevisitoclass_type) ... etc.
		#endif
		v->visit(this);
		}
	
	void* construct() {
		return construct_worker(func, sttr::is_variable<T>());
		}
	
	/// Returns the type of T as a human readable string
	std::string getTypeName() { return sttr::getTypeName<T>(); }
	std::string getTypePointingTo() { return sttr::getTypeName<decltype(sttr::getTypePointingTo(func))>(); }
	
	/// Get the raw offset of a pointer
	unsigned char const * getAddr() const {
		unsigned char const * first  = reinterpret_cast<unsigned char const *>(&func);
		return reinterpret_cast<unsigned char *>(*first);
		}
		
	const long long int getOffset() const {
		return reinterpret_cast<size_t>(getAddr());
		}
	};


class RegNamespace {
public:
	RegNamespace * parent;
	const char * name;
	std::vector<RegBase*> members;
	std::vector<RegNamespace*>classes;
	RegBase * thisClass; // Is not null if this represents a class
	void * thisClassSig;
	
	RegNamespace(const char * _name) : parent(NULL), name(_name), thisClass(NULL), thisClassSig(NULL) {}
	~RegNamespace() {
		for (RegBase * RB : members) delete RB;
		for (RegNamespace * RN : classes) delete RN;
		if (thisClass) delete thisClass;
		}
		
	template <typename CT = sttr::NullType, typename T = sttr::NullType>
	RegNamespace & regField(T v, const char * _name) {
		// for registration of anything
		RegBase * R = new Reg<T, CT>(v,_name);
		R->isFunction = sttr::is_function<T>::value;
		R->isVariable = sttr::is_variable<T>::value;
		R->isConst = sttr::is_const<T>::value;
		R->isStatic = sttr::is_static<T>::value;
		R->mNamespace = this;
		members.push_back(R);
		return *this;
		}
	template <typename CT, typename T>
	RegNamespace & regField(T CT::* v, const char * _name) {
		// easy reigstation of class members
		return regField<CT,T CT::*>(v, _name);
		}
		
	RegNamespace & setUserFlags (const uint32_t & userFlags) {
		// Sets the userFlags for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserFlags without registering a field");
		RegBase * R = members[members.size()-1];
		R->userFlags = userFlags;
		return *this;
		}
	RegNamespace & setUserString (const std::string & userString) {
		// Sets the userString for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserString without registering a field");
		RegBase * R = members[members.size()-1];
		R->userString = userString;
		return *this;
		}
	RegNamespace & setUserData (void * userData) {
		// Sets the userString for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserData without registering a field");
		RegBase * R = members[members.size()-1];
		R->userData = userData;
		return *this;
		}

	template<typename T>
	RegNamespace & beginClass(const char * _name) {
		RegNamespace * R = new RegNamespace(_name);
		R->parent = this;
		R->thisClass = new Reg<T*, sttr::NullType>(NULL, _name);
		R->thisClassSig = sttr::getTypeSignature<T>();
		classes.push_back(R);
		return *(classes[classes.size()-1]);
		}
		
	RegNamespace & endClass() {
		if (parent) return *parent;
		return *this;
		}
	
	void* construct_retVoidPtr() {
		if (thisClass) {
			return thisClass->construct();
			}
		return NULL;
		}
	
	template<typename T>
	T * construct() {
		return (T*) construct_retVoidPtr();
		}
	
	RegNamespace & findClass(const char * class_name) {
		RegNamespace * R = findClassPointer(class_name);
		assert(R && "sttr::RegNamespace::findClass : class not found");
		return *R;
		}
	
	RegNamespace * findClassPointer(const char * class_name) {
		for (RegNamespace * R : classes) {
			if (R->thisClass) {
				if (!strcmp(R->thisClass->name, class_name))
					return R;
				}		
			}
		for (RegNamespace * R : classes) {
			RegNamespace * R2 = R->findClassPointer(class_name);
			if (R2)
				return R2;
			}
		return NULL;
		}
	
	RegNamespace * findClassPointerBySig(void * target) {
		if (target == thisClassSig) return this;
		for (RegNamespace * R : classes) {
			if (R->thisClass) {
				if (R->thisClassSig == target)
					return R;
				}
			}
		for (RegNamespace * R : classes) {
			RegNamespace * R2 = R->findClassPointerBySig(target);
			if (R2)
				return R2;
			}
		return NULL;
		}
	
	void visitRecursive(Visitor_Base * v) {
		// Recusively visits all classes and members
		for (RegNamespace * R : classes) {
			R->visitRecursive(v);
			}
		visit(v);
		}
		
	void visit(Visitor_Base * v) {
		// Recusively visits members
		for (RegBase * RB : members) {
			RB->visit(v);
			}
		}
		
	std::string toString(const int indent=0) {
		std::string r = "";
		for (RegBase * RB : members) {
			r += std::string(indent,'\t') + "\tField: "+ RB->name + "\tTypedef: " + RB->getTypeName() + ", Pointing To: " + RB->getTypePointingTo()+ ", isStatic: " + STTR_BTOS(RB->isStatic) + " , isConst: " + STTR_BTOS(RB->isConst) + ", isFunction: " + STTR_BTOS(RB->isFunction) + ", isVariable: " + STTR_BTOS(RB->isVariable) + "\n";
			}
		for (RegNamespace * RS : classes) {
			r += std::string(indent,'\t') + "class " + RS->name + ":\n";
			r += RS->toString(indent+1);
			}
		return r;
		}
	
	};
	
RegNamespace * getGlobalNamespace() {
	static RegNamespace R("global");
	return &R;
	}
	
}


