#hdr
// STTR - STT Reflection Library
// By Liam Twigger - 2020
// @SnapperTheTwig
// Public Domain

#include <type_traits>
#include <vector>
#include <cassert>
#include <cstring>
#include <string>

#ifndef STTR_VISITOR_HEADER
	#include "sttr_visitor.h"
#endif
		
#define STTR_BTOS(B) (B ? "true" : "false")

// STTR_VISITORS Must be defined before #include "sttr.h"
//#define STTR_VISITORS \
//	STTR_ADD_VISITOR(visitoclass_x) \
//	STTR_ADD_VISITOR(visitoclass_y) \
//	STTR_ADD_VISITOR(visitoclass_z) 

//#define STTR_VISITORS
// \
	STTR_ADD_VISITOR(Typename_Extractor_Visitor);

#end

#src
	
#end

namespace sttr {
	
	
std::string getTypeName_filterTypeOut(const std::string & in) {
	// Find "with T = " and stop when reaching ";"
	size_t start = in.find("T = ");
	if (start == std::string::npos) return in;
	std::string r = in.substr(start+4);
	size_t end = r.find(";");
	return r.substr(0,end);
	}

/// Prints the type of a function
template<typename T>
std::string getTypeName() {
	return sttr::getTypeName_filterTypeOut(__PRETTY_FUNCTION__);
	}

class RegBase {
public:
	const char * name;
	bool isStatic;
	bool isConst;
	bool isVariable;
	bool isFunction;
	
	// For your usage
	uint32_t userFlags;
	std::string userString;
	void * userData;
	
	RegBase(const char * _name) : name(_name), isStatic(false), isConst(false), isVariable(false), isFunction(false), userFlags(0), userString(""), userData(NULL) {}
	virtual ~RegBase(){}
	
	virtual void visit(Visitor_Base * V) {}
	virtual std::string getTypeName() { return ""; }
	virtual unsigned char const * getAddr() { return 0; }
	};
	
template<typename T>
class Reg : public RegBase {
public:
	T func;
	
	Reg(T v, const char * _name) : RegBase(_name), func(v) {}
	virtual ~Reg(){}
	
	void visit(Visitor_Base * v) {
		// Upcast and get the right visitor
		#ifdef STTR_VISITORS
			STTR_VISITORS
		#else
			#warning STTR_VISITORS macro not defined! To suppress this warning define it as an empty string "#define STTR_VISITORS". To add a visitor use #define STTR_VISITORS STTR_ADD_VISITOR(visitoclass_type) STTR_ADD_VISITOR(anothevisitoclass_type) ... etc.
		#endif
		v->visit(this);
		}
	
	/// Returns the type of T as a human readable string
	std::string getTypeName() { return sttr::getTypeName<T>(); }
	
	/// Get the raw address of a pointer
	unsigned char const * getAddr() {
		unsigned char const * first  = reinterpret_cast<unsigned char *>(&func);
		return reinterpret_cast<unsigned char *>(*first);
		}
	};

class RegNamespace {
public:
	RegNamespace * parent;
	const char * name;
	std::vector<RegBase*> members;
	std::vector<RegNamespace*>classes;
	RegBase * thisClass; // Is not null if this represents a class
	
	RegNamespace(const char * _name) : parent(NULL), name(_name), thisClass(NULL) {}
	~RegNamespace() {
		for (RegBase * RB : members) delete RB;
		for (RegNamespace * RN : classes) delete RN;
		if (thisClass) delete thisClass;
		}
	
	template <typename T>
	RegNamespace & regField(T v, const char * _name) {
		RegBase * R = new Reg<T>(v,_name);
		R->isFunction = std::is_function<typename std::remove_pointer<T>::type>::value;
		R->isVariable = !R->isFunction;
		R->isConst = std::is_const<typename std::remove_pointer<T>::type>::value;
		R->isStatic = parent && !std::is_member_pointer<T>::value;
		members.push_back(R);
		return *this;
		}
		
	RegNamespace & setUserFlags (const uint32_t & userFlags) {
		// Sets the userFlags for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserFlags without registering a field");
		RegBase * R = members[members.size()-1];
		R->userFlags = userFlags;
		return *this;
		}
	RegNamespace & setUserString (const std::string & userString) {
		// Sets the userString for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserString without registering a field");
		RegBase * R = members[members.size()-1];
		R->userString = userString;
		return *this;
		}
	RegNamespace & setUserData (void * userData) {
		// Sets the userString for the last inserted member
		assert (members.size() && "Trying to sttr::RegNamespace::setUserData without registering a field");
		RegBase * R = members[members.size()-1];
		R->userData = userData;
		return *this;
		}

	template<typename T>
	RegNamespace & beginClass(const char * _name) {
		RegNamespace * R = new RegNamespace(_name);
		R->parent = this;
		R->thisClass = new Reg<T*>(NULL, _name);
		classes.push_back(R);
		return *(classes[classes.size()-1]);
		}
		
	RegNamespace & endClass() {
		if (parent) return *parent;
		return *this;
		}
	
	RegNamespace & findClass(const char * class_name) {
		RegNamespace * R = findClassPointer(class_name);
		assert(R && "sttr::RegNamespace::findClass : class not found");
		return *R;
		}
	
	RegNamespace * findClassPointer(const char * class_name) {
		for (RegNamespace * R : classes) {
			if (R->thisClass) {
				if (!strcmp(R->thisClass->name, class_name))
					return R;
				}		
			}
		for (RegNamespace * R : classes) {
			RegNamespace * R2 = R->findClassPointer(class_name);
			if (R2)
				return R2;
			}
		return NULL;
		}
		
	void visitRecursive(Visitor_Base * v) {
		// Recusively visits all classes and members
		for (RegNamespace * R : classes) {
			R->visitRecursive(v);
			}
		visit(v);
		}
		
	void visit(Visitor_Base * v) {
		// Recusively visits members
		for (RegBase * RB : members) {
			RB->visit(v);
			}
		}
		
	std::string toString(const int indent=0) {
		std::string r = "";
		for (RegBase * RB : members) {
			r += std::string(indent,'\t') + "\tField: "+ RB->name + "\tTypedef: " + RB->getTypeName() + " isStatic: " + STTR_BTOS(RB->isStatic) + " , isConst: " + STTR_BTOS(RB->isConst) + ", isFunction: " + STTR_BTOS(RB->isFunction) + ", isVariable: " + STTR_BTOS(RB->isVariable) + "\n";
			}
		for (RegNamespace * RS : classes) {
			r += std::string(indent,'\t') + "class " + RS->name + ":\n";
			r += RS->toString(indent+1);
			}
		return r;
		}
	
	};
}


